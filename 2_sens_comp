#define F_CPU 8000000UL  // 8 MHz

#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include <string.h>
#include "twi_lcd.h"

// Definiciones de pines para ATmega16
#define SS1_PIN     PB4     // Pin 5 (SS para primer lector)
#define SS2_PIN     PB3     // Pin 4 (SS para segundo lector)
#define SS3_PIN     PB2     // Pin 3 (SS para tercer lector)
#define SS4_PIN     PB1     // Pin 2 (SS para cuarto lector)
#define MOSI_PIN    PB5     // Pin 6 (MOSI) - Compartido
#define MISO_PIN    PB6     // Pin 7 (MISO) - Compartido
#define SCK_PIN     PB7     // Pin 8 (SCK) - Compartido
#define RST_PIN     PB0     // Pin 1 (RST) - Compartido

// Pin para LED o relé de acceso
#define ACCESS_PIN  PD7     // Pin para activar acceso (LED/Relé)

// Comandos MFRC522
#define PCD_IDLE                0x00
#define PCD_AUTHENT             0x0E
#define PCD_RECEIVE             0x08
#define PCD_TRANSMIT            0x04
#define PCD_TRANSCEIVE          0x0C
#define PCD_RESETPHASE          0x0F
#define PCD_CALCCRC             0x03

// Registros MFRC522
#define CommandReg              0x01
#define ComIEnReg               0x02
#define DivIEnReg               0x03
#define ComIrqReg               0x04
#define DivIrqReg               0x05
#define ErrorReg                0x06
#define Status1Reg              0x07
#define Status2Reg              0x08
#define FIFODataReg             0x09
#define FIFOLevelReg            0x0A
#define WaterLevelReg           0x0B
#define ControlReg              0x0C
#define BitFramingReg           0x0D
#define CollReg                 0x0E
#define ModeReg                 0x11
#define TxModeReg               0x12
#define RxModeReg               0x13
#define TxControlReg            0x14
#define TxAutoReg               0x15
#define TxSelReg                0x16
#define RxSelReg                0x17
#define RxThresholdReg          0x18
#define DemodReg                0x19
#define MfTxReg                 0x1C
#define MfRxReg                 0x1D
#define SerialSpeedReg          0x1F
#define CRCResultRegM           0x21
#define CRCResultRegL           0x22
#define ModWidthReg             0x24
#define RFCfgReg                0x26
#define GsNReg                  0x27
#define CWGsPReg                0x28
#define ModGsPReg               0x29
#define TModeReg                0x2A
#define TPrescalerReg           0x2B
#define TReloadRegH             0x2C
#define TReloadRegL             0x2D
#define TCounterValueRegH       0x2E
#define TCounterValueRegL       0x2F
#define TestSel1Reg             0x31
#define TestSel2Reg             0x32
#define TestPinEnReg            0x33
#define TestPinValueReg         0x34
#define TestBusReg              0x35
#define AutoTestReg             0x36
#define VersionReg              0x37
#define AnalogTestReg           0x38
#define TestDAC1Reg             0x39
#define TestDAC2Reg             0x3A
#define TestADCReg              0x3B

// Comandos PICC
#define PICC_CMD_REQA           0x26
#define PICC_CMD_WUPA           0x52
#define PICC_CMD_CT             0x88
#define PICC_CMD_SEL_CL1        0x93
#define PICC_CMD_SEL_CL2        0x95
#define PICC_CMD_SEL_CL3        0x97
#define PICC_CMD_HLTA           0x50

// Estados de retorno
#define MI_OK                   0
#define MI_NOTAGERR             1
#define MI_ERR                  2

// Configuración para múltiples UIDs
#define EEPROM_START_ADDRESS    0x10    // Dirección inicial en EEPROM
#define MAX_AUTHORIZED_UIDS     40      // Máximo número de UIDs autorizadas (aumentado)
#define UID_SIZE                4       // Tamaño de cada UID en bytes
#define EEPROM_BLOCK_SIZE       8       // 4 bytes UID + 4 bytes de separación/control
#define NUM_READERS             4       // Número de lectores RFID

// Modos de operación
#define MODE_NORMAL             0       // Modo normal de verificación
#define MODE_ADD_CARD           1       // Modo para agregar tarjetas

// Estructura para almacenar la UID
typedef struct {
    uint8_t size;
    uint8_t uidByte[10];
    uint8_t sak;
} Uid;

// Variables globales para almacenar las UIDs de los 4 lectores
Uid cardUID[NUM_READERS];    // Array de UIDs para cada lector
uint8_t cardPresent[NUM_READERS] = {0, 0, 0, 0}; // Flags de tarjeta presente
uint8_t cardAuthorized[NUM_READERS] = {0, 0, 0, 0}; // Flags de autorización

// Variable para modo de operación
uint8_t operationMode = MODE_NORMAL;

// Prototipos de funciones EEPROM
void EEPROM_write(unsigned int uiAddress, unsigned char ucData);
unsigned char EEPROM_read(unsigned int uiAddress);
void initializeEEPROM(void);
uint8_t isValidUID(uint8_t* uid);
uint8_t getNextFreeSlot(void);
uint8_t checkUID_Authorization(uint8_t readerNum);
uint8_t addUID_ToEEPROM(uint8_t* uid);
void displayAuthorizedCount(void);

// Prototipos de funciones MFRC522
void SPI_Init(void);
uint8_t SPI_Transfer(uint8_t data);
void MFRC522_Init(uint8_t reader);
void MFRC522_Reset(uint8_t reader);
uint8_t MFRC522_ReadRegister(uint8_t reg, uint8_t reader);
void MFRC522_WriteRegister(uint8_t reg, uint8_t value, uint8_t reader);
void MFRC522_SetBitMask(uint8_t reg, uint8_t mask, uint8_t reader);
void MFRC522_ClearBitMask(uint8_t reg, uint8_t mask, uint8_t reader);
void MFRC522_AntennaOn(uint8_t reader);
uint8_t MFRC522_ToCard(uint8_t command, uint8_t *sendData, uint8_t sendLen, uint8_t *backData, uint16_t *backLen, uint8_t reader);
uint8_t MFRC522_Request(uint8_t reqMode, uint8_t *TagType, uint8_t reader);
uint8_t MFRC522_Anticoll(uint8_t *serNum, uint8_t reader);
uint8_t MFRC522_IsNewCardPresent(uint8_t reader);
uint8_t MFRC522_ReadCardSerial(uint8_t reader);

// Funciones de interfaz y control
void selectReader(uint8_t reader);
void displayStatus(void);
void displayUID_LCD(uint8_t readerNum);
void displayAccessResult(void);
void byteToHex(uint8_t value, char* hexString);
void checkAllReaders(void);
void processAccess(void);
void activateAccess(void);
void deactivateAccess(void);

int main(void) {
    // Configurar pin de acceso como salida
    DDRD |= (1<<ACCESS_PIN);
    PORTD &= ~(1<<ACCESS_PIN); // Inicialmente desactivado
    
    // Inicialización
    twi_init();                 // TWI Initialize
    twi_lcd_init();             // TWI LCD Initialize
    SPI_Init();                 // SPI Initialize
    
    // Inicializar los 4 lectores RFID
    for(uint8_t i = 1; i <= NUM_READERS; i++) {
        MFRC522_Init(i);
    }
    
    // Inicializar EEPROM para múltiples UIDs
    initializeEEPROM();
    
    // Mostrar mensaje inicial
    twi_lcd_cmd(0x01);          // Clear display
    twi_lcd_msg("4-RFID Access");
    twi_lcd_cmd(0xC0);          // Segunda línea
    twi_lcd_msg("System v1.0");
    
    _delay_ms(2000);
    
    // Mostrar cantidad de UIDs autorizadas
    displayAuthorizedCount();
    _delay_ms(2000);
    
    // Mostrar estado inicial
    displayStatus();
    
    while(1) {
        // Verificar todos los lectores
        checkAllReaders();
        
        // Procesar acceso si hay alguna tarjeta presente
        if(cardPresent[0] || cardPresent[1] || cardPresent[2] || cardPresent[3]) {
            processAccess();
            
            // Esperar a que se retiren las tarjetas
            _delay_ms(3000);
            
            // Resetear flags
            for(uint8_t i = 0; i < NUM_READERS; i++) {
                cardPresent[i] = 0;
                cardAuthorized[i] = 0;
                cardUID[i].size = 0;
            }
            
            // Desactivar acceso
            deactivateAccess();
            
            // Volver a mostrar estado
            displayStatus();
        }
        
        _delay_ms(100); // Pequeña pausa entre lecturas
    }
    
    return 0;
}

// Verificar todos los lectores
void checkAllReaders(void) {
    for(uint8_t reader = 1; reader <= NUM_READERS; reader++) {
        if(MFRC522_IsNewCardPresent(reader)) {
            if(MFRC522_ReadCardSerial(reader)) {
                cardPresent[reader-1] = 1;
                // Verificar autorización inmediatamente
                cardAuthorized[reader-1] = checkUID_Authorization(reader);
            }
        }
    }
}

// Procesar acceso basado en las tarjetas presentes
void processAccess(void) {
    uint8_t authorizedCount = 0;
    uint8_t presentCount = 0;
    
    // Contar tarjetas presentes y autorizadas
    for(uint8_t i = 0; i < NUM_READERS; i++) {
        if(cardPresent[i]) {
            presentCount++;
            if(cardAuthorized[i]) {
                authorizedCount++;
            }
        }
    }
    
    // Mostrar estado de cada lector
    twi_lcd_cmd(0x01);
    
    // Primera línea: R1 y R2
    char line1[17] = "R1:";
    if(cardPresent[0]) {
        strcat(line1, cardAuthorized[0] ? "OK " : "NO ");
    } else {
        strcat(line1, "-- ");
    }
    strcat(line1, "R2:");
    if(cardPresent[1]) {
        strcat(line1, cardAuthorized[1] ? "OK" : "NO");
    } else {
        strcat(line1, "--");
    }
    twi_lcd_msg(line1);
    
    // Segunda línea: R3 y R4
    twi_lcd_cmd(0xC0);
    char line2[17] = "R3:";
    if(cardPresent[2]) {
        strcat(line2, cardAuthorized[2] ? "OK " : "NO ");
    } else {
        strcat(line2, "-- ");
    }
    strcat(line2, "R4:");
    if(cardPresent[3]) {
        strcat(line2, cardAuthorized[3] ? "OK" : "NO");
    } else {
        strcat(line2, "--");
    }
    twi_lcd_msg(line2);
    
    _delay_ms(2000);
    
    // Decidir si otorgar acceso (todas las tarjetas presentes deben estar autorizadas)
    if(presentCount > 0 && authorizedCount == presentCount) {
        // Acceso otorgado
        activateAccess();
        displayAccessResult();
    } else {
        // Acceso denegado
        deactivateAccess();
        
        twi_lcd_cmd(0x01);
        twi_lcd_msg("Acceso Denegado");
        twi_lcd_cmd(0xC0);
        
        if(presentCount > authorizedCount) {
            // Hay tarjetas no autorizadas
            twi_lcd_msg("Tarjeta invalida");
            
            _delay_ms(2000);
            
            // Opción de agregar tarjeta no autorizada
            if(operationMode == MODE_ADD_CARD) {
                for(uint8_t i = 0; i < NUM_READERS; i++) {
                    if(cardPresent[i] && !cardAuthorized[i]) {
                        twi_lcd_cmd(0x01);
                        twi_lcd_msg("Agregar R");
                        char num[2] = {i + '1', '\0'};
                        twi_lcd_msg(num);
                        twi_lcd_msg("?");
                        twi_lcd_cmd(0xC0);
                        
                        // Mostrar UID
                        char uidStr[17];
                        uidStr[0] = '\0';
                        for(uint8_t j = 0; j < 4 && j < cardUID[i].size; j++) {
                            char hex[3];
                            byteToHex(cardUID[i].uidByte[j], hex);
                            strcat(uidStr, hex);
                            if(j < 3) strcat(uidStr, " ");
                        }
                        twi_lcd_msg(uidStr);
                        
                        _delay_ms(3000);
                        
                        // Agregar la tarjeta
                        if(addUID_ToEEPROM(cardUID[i].uidByte)) {
                            twi_lcd_cmd(0x01);
                            twi_lcd_msg("Tarjeta agregada");
                            twi_lcd_cmd(0xC0);
                            twi_lcd_msg("exitosamente!");
                        } else {
                            twi_lcd_cmd(0x01);
                            twi_lcd_msg("Error: Memoria");
                            twi_lcd_cmd(0xC0);
                            twi_lcd_msg("EEPROM llena!");
                        }
                        _delay_ms(2000);
                    }
                }
            }
        }
    }
}

// Activar acceso (LED/Relé)
void activateAccess(void) {
    PORTD |= (1<<ACCESS_PIN);
}

// Desactivar acceso
void deactivateAccess(void) {
    PORTD &= ~(1<<ACCESS_PIN);
}

// Mostrar resultado de acceso
void displayAccessResult(void) {
    twi_lcd_cmd(0x01);
    twi_lcd_msg("*** ACCESO ***");
    twi_lcd_cmd(0xC0);
    twi_lcd_msg("  OTORGADO");
}

// Mostrar estado del sistema
void displayStatus(void) {
    twi_lcd_cmd(0x01);
    twi_lcd_msg("Sistema listo");
    twi_lcd_cmd(0xC0);
    twi_lcd_msg("Acerque tarjetas");
}

// Función para seleccionar el lector activo
void selectReader(uint8_t reader) {
    // Primero, desactivar todos los SS (ponerlos en alto)
    PORTB |= (1<<SS1_PIN) | (1<<SS2_PIN) | (1<<SS3_PIN) | (1<<SS4_PIN);
    
    // Activar solo el lector seleccionado (ponerlo en bajo)
    switch(reader) {
        case 1:
            PORTB &= ~(1<<SS1_PIN);
            break;
        case 2:
            PORTB &= ~(1<<SS2_PIN);
            break;
        case 3:
            PORTB &= ~(1<<SS3_PIN);
            break;
        case 4:
            PORTB &= ~(1<<SS4_PIN);
            break;
    }
}

// Implementación de funciones EEPROM
void EEPROM_write(unsigned int uiAddress, unsigned char ucData) {
    while(EECR & (1<<EEWE));
    EEAR = uiAddress;
    EEDR = ucData;
    EECR |= (1<<EEMWE);
    EECR |= (1<<EEWE);
}

unsigned char EEPROM_read(unsigned int uiAddress) {
    while(EECR & (1<<EEWE));
    EEAR = uiAddress;
    EECR |= (1<<EERE);
    return EEDR;
}

void initializeEEPROM(void) {
    if (EEPROM_read(EEPROM_START_ADDRESS - 1) != 0xAA) {
        for (uint16_t i = 0; i < (MAX_AUTHORIZED_UIDS * EEPROM_BLOCK_SIZE); i++) {
            EEPROM_write(EEPROM_START_ADDRESS + i, 0xFF);
        }
        EEPROM_write(EEPROM_START_ADDRESS - 1, 0xAA);
    }
}

uint8_t isValidUID(uint8_t* uid) {
    for (uint8_t i = 0; i < UID_SIZE; i++) {
        if (uid[i] != 0xFF && uid[i] != 0x00) {
            return 1;
        }
    }
    return 0;
}

uint8_t getNextFreeSlot(void) {
    uint8_t temp_uid[UID_SIZE];
    
    for (uint8_t slot = 0; slot < MAX_AUTHORIZED_UIDS; slot++) {
        for (uint8_t i = 0; i < UID_SIZE; i++) {
            temp_uid[i] = EEPROM_read(EEPROM_START_ADDRESS + (slot * EEPROM_BLOCK_SIZE) + i);
        }
        
        if (!isValidUID(temp_uid)) {
            return slot;
        }
    }
    
    return 0xFF;
}

uint8_t checkUID_Authorization(uint8_t readerNum) {
    uint8_t temp_uid[UID_SIZE];
    uint8_t match;
    uint8_t readerIndex = readerNum - 1;
    
    for (uint8_t slot = 0; slot < MAX_AUTHORIZED_UIDS; slot++) {
        for (uint8_t i = 0; i < UID_SIZE; i++) {
            temp_uid[i] = EEPROM_read(EEPROM_START_ADDRESS + (slot * EEPROM_BLOCK_SIZE) + i);
        }
        
        if (isValidUID(temp_uid)) {
            match = 1;
            for (uint8_t i = 0; i < UID_SIZE; i++) {
                if (cardUID[readerIndex].uidByte[i] != temp_uid[i]) {
                    match = 0;
                    break;
                }
            }
            
            if (match) {
                return 1;
            }
        }
    }
    
    return 0;
}

uint8_t addUID_ToEEPROM(uint8_t* uid) {
    uint8_t free_slot = getNextFreeSlot();
    
    if (free_slot == 0xFF) {
        return 0;
    }
    
    for (uint8_t i = 0; i < UID_SIZE; i++) {
        EEPROM_write(EEPROM_START_ADDRESS + (free_slot * EEPROM_BLOCK_SIZE) + i, uid[i]);
    }
    
    return 1;
}

void displayAuthorizedCount(void) {
    uint8_t count = 0;
    uint8_t temp_uid[UID_SIZE];
    char count_str[17];
    
    for (uint8_t slot = 0; slot < MAX_AUTHORIZED_UIDS; slot++) {
        for (uint8_t i = 0; i < UID_SIZE; i++) {
            temp_uid[i] = EEPROM_read(EEPROM_START_ADDRESS + (slot * EEPROM_BLOCK_SIZE) + i);
        }
        if (isValidUID(temp_uid)) {
            count++;
        }
    }
    
    twi_lcd_cmd(0x01);
    twi_lcd_msg("UIDs autorizadas");
    twi_lcd_cmd(0xC0);
    
    if (count == 0) {
        strcpy(count_str, "0");
    } else {
        uint8_t temp = count;
        uint8_t digits = 0;
        
        while (temp > 0) {
            digits++;
            temp /= 10;
        }
        
        count_str[digits] = '\0';
        temp = count;
        
        for (int8_t i = digits - 1; i >= 0; i--) {
            count_str[i] = '0' + (temp % 10);
            temp /= 10;
        }
    }
    
    strcat(count_str, " de ");
    
    char max_str[4];
    uint8_t max_temp = MAX_AUTHORIZED_UIDS;
    uint8_t max_digits = 0;
    
    while (max_temp > 0) {
        max_digits++;
        max_temp /= 10;
    }
    
    max_str[max_digits] = '\0';
    max_temp = MAX_AUTHORIZED_UIDS;
    
    for (int8_t i = max_digits - 1; i >= 0; i--) {
        max_str[i] = '0' + (max_temp % 10);
        max_temp /= 10;
    }
    
    strcat(count_str, max_str);
    twi_lcd_msg(count_str);
}

void byteToHex(uint8_t value, char* hexString) {
    const char hex[] = "0123456789ABCDEF";
    hexString[0] = hex[value >> 4];
    hexString[1] = hex[value & 0x0F];
    hexString[2] = '\0';
}

// Implementación de funciones SPI
void SPI_Init(void) {
    // Configurar pines SPI (todos los SS como salidas)
    DDRB |= (1<<MOSI_PIN)|(1<<SCK_PIN)|(1<<SS1_PIN)|(1<<SS2_PIN)|(1<<SS3_PIN)|(1<<SS4_PIN);
    DDRB &= ~(1<<MISO_PIN); // MISO como entrada
    DDRB |= (1<<RST_PIN); // RST como salida
    
    // Todos los SS en alto inicialmente (ningún lector seleccionado)
    PORTB |= (1<<SS1_PIN)|(1<<SS2_PIN)|(1<<SS3_PIN)|(1<<SS4_PIN);
    
    // Habilitar SPI, Master, set clock rate fck/16
    SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
}

uint8_t SPI_Transfer(uint8_t data) {
    SPDR = data;
    while(!(SPSR & (1<<SPIF)));
    return SPDR;
}

// Implementación de funciones MFRC522
void MFRC522_Init(uint8_t reader) {
    MFRC522_Reset(reader);
    
    MFRC522_WriteRegister(TModeReg, 0x8D, reader);
    MFRC522_WriteRegister(TPrescalerReg, 0x3E, reader);
    MFRC522_WriteRegister(TReloadRegL, 30, reader);
    MFRC522_WriteRegister(TReloadRegH, 0, reader);
    
    MFRC522_WriteRegister(TxAutoReg, 0x40, reader);
    MFRC522_WriteRegister(ModeReg, 0x3D, reader);
    
    MFRC522_AntennaOn(reader);
}

void MFRC522_Reset(uint8_t reader) {
    MFRC522_WriteRegister(CommandReg, PCD_RESETPHASE, reader);
}

uint8_t MFRC522_ReadRegister(uint8_t reg, uint8_t reader) {
    uint8_t value;
    selectReader(reader);
    SPI_Transfer(((reg<<1)&0x7E)|0x80);
    value = SPI_Transfer(0x00);
    PORTB |= (1<<SS1_PIN)|(1<<SS2_PIN)|(1<<SS3_PIN)|(1<<SS4_PIN);
    return value;
}

void MFRC522_WriteRegister(uint8_t reg, uint8_t value, uint8_t reader) {
    selectReader(reader);
    SPI_Transfer((reg<<1)&0x7E);
    SPI_Transfer(value);
    PORTB |= (1<<SS1_PIN)|(1<<SS2_PIN)|(1<<SS3_PIN)|(1<<SS4_PIN);
}

void MFRC522_SetBitMask(uint8_t reg, uint8_t mask, uint8_t reader) {
    uint8_t tmp = MFRC522_ReadRegister(reg, reader);
    MFRC522_WriteRegister(reg, tmp | mask, reader);
}

void MFRC522_ClearBitMask(uint8_t reg, uint8_t mask, uint8_t reader) {
    uint8_t tmp = MFRC522_ReadRegister(reg, reader);
    MFRC522_WriteRegister(reg, tmp & (~mask), reader);
}

void MFRC522_AntennaOn(uint8_t reader) {
    uint8_t temp = MFRC522_ReadRegister(TxControlReg, reader);
    if (!(temp & 0x03)) {
        MFRC522_SetBitMask(TxControlReg, 0x03, reader);
    }
}

uint8_t MFRC522_ToCard(uint8_t command, uint8_t *sendData, uint8_t sendLen, uint8_t *backData, uint16_t *backLen, uint8_t reader) {
    uint8_t status = MI_ERR;
    uint8_t irqEn = 0x00;
    uint8_t waitIRq = 0x00;
    uint8_t lastBits;
    uint8_t n;
    uint16_t i;
    
    switch (command) {
        case PCD_AUTHENT:
            irqEn = 0x12;
            waitIRq = 0x10;
            break;
        case PCD_TRANSCEIVE:
            irqEn = 0x77;
            waitIRq = 0x30;
            break;
        default:
            break;
    }
    
    MFRC522_WriteRegister(ComIEnReg, irqEn|0x80, reader);
    MFRC522_ClearBitMask(ComIrqReg, 0x80, reader);
    MFRC522_SetBitMask(FIFOLevelReg, 0x80, reader);
    
    MFRC522_WriteRegister(CommandReg, PCD_IDLE, reader);
    
    for (i=0; i<sendLen; i++) {
        MFRC522_WriteRegister(FIFODataReg, sendData[i], reader);
    }
    
    MFRC522_WriteRegister(CommandReg, command, reader);
    if (command == PCD_TRANSCEIVE) {
        MFRC522_SetBitMask(BitFramingReg, 0x80, reader);
    }
    
    i = 2000;
    do {
        n = MFRC522_ReadRegister(ComIrqReg, reader);
        i--;
    } while ((i!=0) && !(n&0x01) && !(n&waitIRq));
    
    MFRC522_ClearBitMask(BitFramingReg, 0x80, reader);
    
    if (i != 0) {
        if(!(MFRC522_ReadRegister(ErrorReg, reader) & 0x1B)) {
            status = MI_OK;
            if (n & irqEn & 0x01) {
                status = MI_NOTAGERR;
            }
            
            if (command == PCD_TRANSCEIVE) {
                n = MFRC522_ReadRegister(FIFOLevelReg, reader);
                lastBits = MFRC522_ReadRegister(ControlReg, reader) & 0x07;
                if (lastBits) {
                    *backLen = (n-1)*8 + lastBits;
                } else {
                    *backLen = n*8;
                }
                
                if (n == 0) {
                    n = 1;
                }
                if (n > 16) {
                    n = 16;
                }
                
                for (i=0; i<n; i++) {
                    backData[i] = MFRC522_ReadRegister(FIFODataReg, reader);
                }
            }
        } else {
            status = MI_ERR;
        }
    }
    
    return status;
}

uint8_t MFRC522_Request(uint8_t reqMode, uint8_t *TagType, uint8_t reader) {
    uint8_t status;
    uint16_t backBits;
    
    MFRC522_WriteRegister(BitFramingReg, 0x07, reader);
    
    TagType[0] = reqMode;
    status = MFRC522_ToCard(PCD_TRANSCEIVE, TagType, 1, TagType, &backBits, reader);
    
    if ((status != MI_OK) || (backBits != 0x10)) {
        status = MI_ERR;
    }
    
    return status;
}

uint8_t MFRC522_Anticoll(uint8_t *serNum, uint8_t reader) {
    uint8_t status;
    uint8_t i;
    uint8_t serNumCheck=0;
    uint16_t unLen;
    
    MFRC522_WriteRegister(BitFramingReg, 0x00, reader);
    
    serNum[0] = PICC_CMD_SEL_CL1;
    serNum[1] = 0x20;
    status = MFRC522_ToCard(PCD_TRANSCEIVE, serNum, 2, serNum, &unLen, reader);
    
    if (status == MI_OK) {
        for (i=0; i<4; i++) {
            serNumCheck ^= serNum[i];
        }
        if (serNumCheck != serNum[i]) {
            status = MI_ERR;
        }
    }
    
    return status;
}

uint8_t MFRC522_IsNewCardPresent(uint8_t reader) {
    uint8_t status;
    uint8_t TagType[2];
    
    status = MFRC522_Request(PICC_CMD_REQA, TagType, reader);
    if (status == MI_OK) {
        return 1;
    } else {
        return 0;
    }
}

uint8_t MFRC522_ReadCardSerial(uint8_t reader) {
    uint8_t status;
    uint8_t serNum[5];
    uint8_t i;
    uint8_t readerIndex = reader - 1;
    
    status = MFRC522_Anticoll(serNum, reader);
    if (status == MI_OK) {
        // Guardar la UID en la variable correspondiente al lector
        cardUID[readerIndex].size = 4; // UID de 4 bytes para tarjetas MIFARE Classic
        for (i = 0; i < 4; i++) {
            cardUID[readerIndex].uidByte[i] = serNum[i];
        }
        return 1;
    } else {
        return 0;
    }
}
