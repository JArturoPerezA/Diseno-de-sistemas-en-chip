#define F_CPU 8000000UL  // 8 MHz

#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include <string.h>
#include "twi_lcd.h"

// Definiciones de pines para ATmega16
#define SS1_PIN     PB4     // Pin 5 (SS para primer lector - Control de acceso)
#define SS2_PIN     PB3     // Pin 4 (SS para segundo lector - Detección)
#define MOSI_PIN    PB5     // Pin 6 (MOSI) - Compartido
#define MISO_PIN    PB6     // Pin 7 (MISO) - Compartido
#define SCK_PIN     PB7     // Pin 8 (SCK) - Compartido
#define RST_PIN     PB0     // Pin 16 (RST) - Compartido
#define LED_PIN     PD7     // Pin para LED de detección sensor 2

// Comandos MFRC522
#define PCD_IDLE                0x00
#define PCD_AUTHENT             0x0E
#define PCD_RECEIVE             0x08
#define PCD_TRANSMIT            0x04
#define PCD_TRANSCEIVE          0x0C
#define PCD_RESETPHASE          0x0F
#define PCD_CALCCRC             0x03

// Registros MFRC522
#define CommandReg              0x01
#define ComIEnReg               0x02
#define DivIEnReg               0x03
#define ComIrqReg               0x04
#define DivIrqReg               0x05
#define ErrorReg                0x06
#define Status1Reg              0x07
#define Status2Reg              0x08
#define FIFODataReg             0x09
#define FIFOLevelReg            0x0A
#define WaterLevelReg           0x0B
#define ControlReg              0x0C
#define BitFramingReg           0x0D
#define CollReg                 0x0E
#define ModeReg                 0x11
#define TxModeReg               0x12
#define RxModeReg               0x13
#define TxControlReg            0x14
#define TxAutoReg               0x15
#define TxSelReg                0x16
#define RxSelReg                0x17
#define RxThresholdReg          0x18
#define DemodReg                0x19
#define MfTxReg                 0x1C
#define MfRxReg                 0x1D
#define SerialSpeedReg          0x1F
#define CRCResultRegM           0x21
#define CRCResultRegL           0x22
#define ModWidthReg             0x24
#define RFCfgReg                0x26
#define GsNReg                  0x27
#define CWGsPReg                0x28
#define ModGsPReg               0x29
#define TModeReg                0x2A
#define TPrescalerReg           0x2B
#define TReloadRegH             0x2C
#define TReloadRegL             0x2D
#define TCounterValueRegH       0x2E
#define TCounterValueRegL       0x2F
#define TestSel1Reg             0x31
#define TestSel2Reg             0x32
#define TestPinEnReg            0x33
#define TestPinValueReg         0x34
#define TestBusReg              0x35
#define AutoTestReg             0x36
#define VersionReg              0x37
#define AnalogTestReg           0x38
#define TestDAC1Reg             0x39
#define TestDAC2Reg             0x3A
#define TestADCReg              0x3B

// Comandos PICC
#define PICC_CMD_REQA           0x26
#define PICC_CMD_WUPA           0x52
#define PICC_CMD_CT             0x88
#define PICC_CMD_SEL_CL1        0x93
#define PICC_CMD_SEL_CL2        0x95
#define PICC_CMD_SEL_CL3        0x97
#define PICC_CMD_HLTA           0x50

// Estados de retorno
#define MI_OK                   0
#define MI_NOTAGERR             1
#define MI_ERR                  2

// Configuración para múltiples UIDs (para sensor 1)
#define EEPROM_START_ADDRESS    0x10    // Dirección inicial en EEPROM
#define MAX_AUTHORIZED_UIDS     20      // Máximo número de UIDs autorizadas
#define UID_SIZE                4       // Tamaño de cada UID en bytes
#define EEPROM_BLOCK_SIZE       8       // 4 bytes UID + 4 bytes de separación/control

// Estructura para almacenar la UID
typedef struct {
	uint8_t size;
	uint8_t uidByte[10];
	uint8_t sak;
} Uid;

// Variables globales para almacenar las UIDs de ambos lectores
Uid cardUID1;    // UID del primer lector (control de acceso)
Uid cardUID2;    // UID del segundo lector (detección)

// Variables de estado
uint8_t ledTimer = 0;  // Contador para apagar el LED después de un tiempo

// Prototipos de funciones EEPROM
void EEPROM_write(unsigned int uiAddress, unsigned char ucData);
unsigned char EEPROM_read(unsigned int uiAddress);

// Prototipos de funciones MFRC522
void SPI_Init(void);
uint8_t SPI_Transfer(uint8_t data);
void MFRC522_Init(uint8_t reader);
void MFRC522_Reset(uint8_t reader);
uint8_t MFRC522_ReadRegister(uint8_t reg, uint8_t reader);
void MFRC522_WriteRegister(uint8_t reg, uint8_t value, uint8_t reader);
void MFRC522_SetBitMask(uint8_t reg, uint8_t mask, uint8_t reader);
void MFRC522_ClearBitMask(uint8_t reg, uint8_t mask, uint8_t reader);
void MFRC522_AntennaOn(uint8_t reader);
uint8_t MFRC522_ToCard(uint8_t command, uint8_t *sendData, uint8_t sendLen, uint8_t *backData, uint16_t *backLen, uint8_t reader);
uint8_t MFRC522_Request(uint8_t reqMode, uint8_t *TagType, uint8_t reader);
uint8_t MFRC522_Anticoll(uint8_t *serNum, uint8_t reader);
uint8_t MFRC522_IsNewCardPresent(uint8_t reader);
uint8_t MFRC522_ReadCardSerial(uint8_t reader);

// Funciones para manejo de UIDs y EEPROM
void displayUID_LCD(uint8_t reader);
void byteToHex(uint8_t value, char* hexString);
uint8_t checkUID_Authorization(void);
void displayAccessResult(uint8_t access_granted);
uint8_t addUID_ToEEPROM(uint8_t* uid);
uint8_t getNextFreeSlot(void);
void initializeEEPROM(void);
uint8_t isValidUID(uint8_t* uid);
void displayAuthorizedCount(void);

// Funciones para control de dispositivos
void selectReader(uint8_t reader);
void LED_Init(void);
void LED_On(void);
void LED_Off(void);
void testSensor2(void);

// Implementación de funciones EEPROM
void EEPROM_write(unsigned int uiAddress, unsigned char ucData) {
	while(EECR & (1<<EEWE));
	EEAR = uiAddress;
	EEDR = ucData;
	EECR |= (1<<EEMWE);
	EECR |= (1<<EEWE);
}

unsigned char EEPROM_read(unsigned int uiAddress) {
	while(EECR & (1<<EEWE));
	EEAR = uiAddress;
	EECR |= (1<<EERE);
	return EEDR;
}

// Inicializar LED
void LED_Init(void) {
	DDRD |= (1<<LED_PIN);  // Configurar pin del LED como salida
	LED_Off();             // Inicialmente apagado
}

void LED_On(void) {
	PORTD |= (1<<LED_PIN);
}

void LED_Off(void) {
	PORTD &= ~(1<<LED_PIN);
}

// Inicializar EEPROM si es la primera vez
void initializeEEPROM(void) {
	if (EEPROM_read(EEPROM_START_ADDRESS - 1) != 0xAA) {
		for (uint16_t i = 0; i < (MAX_AUTHORIZED_UIDS * EEPROM_BLOCK_SIZE); i++) {
			EEPROM_write(EEPROM_START_ADDRESS + i, 0xFF);
		}
		EEPROM_write(EEPROM_START_ADDRESS - 1, 0xAA);
	}
}

// Verificar si una UID es válida
uint8_t isValidUID(uint8_t* uid) {
	for (uint8_t i = 0; i < UID_SIZE; i++) {
		if (uid[i] != 0xFF && uid[i] != 0x00) {
			return 1;
		}
	}
	return 0;
}

// Buscar el próximo slot libre en EEPROM
uint8_t getNextFreeSlot(void) {
	uint8_t temp_uid[UID_SIZE];
	
	for (uint8_t slot = 0; slot < MAX_AUTHORIZED_UIDS; slot++) {
		for (uint8_t i = 0; i < UID_SIZE; i++) {
			temp_uid[i] = EEPROM_read(EEPROM_START_ADDRESS + (slot * EEPROM_BLOCK_SIZE) + i);
		}
		
		if (!isValidUID(temp_uid)) {
			return slot;
		}
	}
	
	return 0xFF;
}

// Verificar si la UID actual está autorizada
uint8_t checkUID_Authorization(void) {
	uint8_t temp_uid[UID_SIZE];
	uint8_t match;
	
	for (uint8_t slot = 0; slot < MAX_AUTHORIZED_UIDS; slot++) {
		for (uint8_t i = 0; i < UID_SIZE; i++) {
			temp_uid[i] = EEPROM_read(EEPROM_START_ADDRESS + (slot * EEPROM_BLOCK_SIZE) + i);
		}
		
		if (isValidUID(temp_uid)) {
			match = 1;
			for (uint8_t i = 0; i < UID_SIZE; i++) {
				if (cardUID1.uidByte[i] != temp_uid[i]) {
					match = 0;
					break;
				}
			}
			
			if (match) {
				return 1;
			}
		}
	}
	
	return 0;
}

// Agregar nueva UID a EEPROM
uint8_t addUID_ToEEPROM(uint8_t* uid) {
	uint8_t free_slot = getNextFreeSlot();
	
	if (free_slot == 0xFF) {
		return 0;
	}
	
	for (uint8_t i = 0; i < UID_SIZE; i++) {
		EEPROM_write(EEPROM_START_ADDRESS + (free_slot * EEPROM_BLOCK_SIZE) + i, uid[i]);
	}
	
	return 1;
}

// Mostrar cantidad de UIDs autorizadas
void displayAuthorizedCount(void) {
	uint8_t count = 0;
	uint8_t temp_uid[UID_SIZE];
	char count_str[17];
	
	for (uint8_t slot = 0; slot < MAX_AUTHORIZED_UIDS; slot++) {
		for (uint8_t i = 0; i < UID_SIZE; i++) {
			temp_uid[i] = EEPROM_read(EEPROM_START_ADDRESS + (slot * EEPROM_BLOCK_SIZE) + i);
		}
		if (isValidUID(temp_uid)) {
			count++;
		}
	}
	
	twi_lcd_cmd(0x01);
	twi_lcd_msg("UIDs autorizadas:");
	twi_lcd_cmd(0xC0);
	
	if (count == 0) {
		strcpy(count_str, "0");
		} else {
		uint8_t temp = count;
		uint8_t digits = 0;
		
		while (temp > 0) {
			digits++;
			temp /= 10;
		}
		
		count_str[digits] = '\0';
		temp = count;
		
		for (int8_t i = digits - 1; i >= 0; i--) {
			count_str[i] = '0' + (temp % 10);
			temp /= 10;
		}
	}
	
	strcat(count_str, " de ");
	
	char max_str[4];
	uint8_t max_temp = MAX_AUTHORIZED_UIDS;
	uint8_t max_digits = 0;
	
	while (max_temp > 0) {
		max_digits++;
		max_temp /= 10;
	}
	
	max_str[max_digits] = '\0';
	max_temp = MAX_AUTHORIZED_UIDS;
	
	for (int8_t i = max_digits - 1; i >= 0; i--) {
		max_str[i] = '0' + (max_temp % 10);
		max_temp /= 10;
	}
	
	strcat(count_str, max_str);
	twi_lcd_msg(count_str);
}

// Función de prueba para el sensor 2
void testSensor2(void) {
	uint8_t version;
	
	// Leer versión del sensor 2
	version = MFRC522_ReadRegister(VersionReg, 2);
	
	twi_lcd_cmd(0x01);
	twi_lcd_msg("Test Sensor 2:");
	twi_lcd_cmd(0xC0);
	
	if (version == 0x91 || version == 0x92) {
		twi_lcd_msg("OK - Version:");
		char hex[3];
		byteToHex(version, hex);
		twi_lcd_msg(hex);
		} else if (version == 0x00 || version == 0xFF) {
		twi_lcd_msg("Error conexion");
		} else {
		twi_lcd_msg("Version:");
		char hex[3];
		byteToHex(version, hex);
		twi_lcd_msg(hex);
	}
	
	_delay_ms(2000);
}

int main(void) {
	// Inicialización
	twi_init();                 // TWI Initialize
	twi_lcd_init();             // TWI LCD Initialize
	SPI_Init();                 // SPI Initialize
	LED_Init();                 // LED Initialize
	
	// Inicializar ambos lectores RFID
	MFRC522_Init(1);            // Inicializar primer lector (control de acceso)
	MFRC522_Init(2);            // Inicializar segundo lector (detección)
	
	// Inicializar EEPROM para control de acceso
	initializeEEPROM();
	
	// Mostrar mensaje inicial
	twi_lcd_cmd(0x01);          // Clear display
	twi_lcd_msg("Sistema Dual");
	twi_lcd_cmd(0xC0);          // Segunda línea
	twi_lcd_msg("RFID Iniciando...");
	
	_delay_ms(2000);
	
	// Probar sensor 2
	testSensor2();
	
	// Mostrar cantidad de UIDs autorizadas
	displayAuthorizedCount();
	_delay_ms(2000);
	
	// Mostrar mensaje de operación normal
	twi_lcd_cmd(0x01);
	twi_lcd_msg("S1:Acceso S2:Det");
	twi_lcd_cmd(0xC0);
	twi_lcd_msg("Esperando...");
	
	uint8_t card1Present = 0;
	uint8_t card2Present = 0;
	uint8_t displayTimer = 0;
	uint8_t sensor1Busy = 0;
	
	while(1) {
		// Solo verificar sensores si no hay operación en curso
		if (!sensor1Busy) {
			// Verificar primer lector (Control de acceso)
			if (MFRC522_IsNewCardPresent(1)) {
				if (MFRC522_ReadCardSerial(1)) {
					sensor1Busy = 1;  // Marcar sensor 1 como ocupado
					card1Present = 1;
					
					// Mostrar UID del sensor 1
					displayUID_LCD(1);
					_delay_ms(1500);
					
					// Verificar autorización
					uint8_t access_granted = checkUID_Authorization();
					
					// Mostrar resultado del acceso
					displayAccessResult(access_granted);
					_delay_ms(2000);
					
					// Si no está autorizada, preguntar si se desea agregar
					if (!access_granted) {
						twi_lcd_cmd(0x01);
						twi_lcd_msg("Agregar UID?");
						twi_lcd_cmd(0xC0);
						twi_lcd_msg("Espere 3s = SI");
						
						_delay_ms(3000);
						
						if (addUID_ToEEPROM(cardUID1.uidByte)) {
							twi_lcd_cmd(0x01);
							twi_lcd_msg("UID Agregada!");
							twi_lcd_cmd(0xC0);
							twi_lcd_msg("Exitosamente");
							} else {
							twi_lcd_cmd(0x01);
							twi_lcd_msg("Memoria llena!");
							twi_lcd_cmd(0xC0);
							twi_lcd_msg("No se agrego");
						}
						_delay_ms(2000);
						
						displayAuthorizedCount();
						_delay_ms(2000);
					}
					
					displayTimer = 50; // Mantener display por 5 segundos
					sensor1Busy = 0;  // Liberar sensor 1
					
					// Pequeña pausa antes de continuar
					_delay_ms(500);
				}
			}
			
			// Verificar segundo lector solo si sensor 1 no está ocupado
			if (!sensor1Busy && MFRC522_IsNewCardPresent(2)) {
				if (MFRC522_ReadCardSerial(2)) {
					card2Present = 1;
					
					// Encender LED
					LED_On();
					ledTimer = 30; // Mantener LED encendido por 3 segundos
					
					// Mostrar detección en LCD si no hay operación del sensor 1
					if (displayTimer == 0) {
						twi_lcd_cmd(0x01);
						twi_lcd_msg("Sensor 2: Detect");
						twi_lcd_cmd(0xC0);
						twi_lcd_msg("LED Activado");
						displayTimer = 20; // Mostrar por 2 segundos
					}
					
					// Pequeña pausa antes de continuar
					_delay_ms(500);
				}
			}
		}
		
		// Control del temporizador del LED
		if (ledTimer > 0) {
			ledTimer--;
			if (ledTimer == 0) {
				LED_Off();
			}
		}
		
		// Control del temporizador del display
		if (displayTimer > 0) {
			displayTimer--;
			if (displayTimer == 0) {
				// Restaurar mensaje normal
				twi_lcd_cmd(0x01);
				twi_lcd_msg("S1:Acceso S2:Det");
				twi_lcd_cmd(0xC0);
				twi_lcd_msg("Esperando...");
				card1Present = 0;
				card2Present = 0;
			}
		}
		
		_delay_ms(100); // Pausa de 100ms entre iteraciones
	}
	
	return 0;
}

void displayAccessResult(uint8_t access_granted) {
	twi_lcd_cmd(0x01);
	
	if (access_granted) {
		twi_lcd_msg("Acceso");
		twi_lcd_cmd(0xC0);
		twi_lcd_msg("Otorgado");
		} else {
		twi_lcd_msg("Acceso");
		twi_lcd_cmd(0xC0);
		twi_lcd_msg("Denegado");
	}
}

void displayUID_LCD(uint8_t reader) {
	char uidString[17];
	char hexByte[3];
	Uid* currentUID;
	
	// Seleccionar la UID correspondiente
	if (reader == 1) {
		currentUID = &cardUID1;
		} else {
		currentUID = &cardUID2;
	}
	
	twi_lcd_cmd(0x01);
	
	// Mostrar de qué sensor es
	if (reader == 1) {
		twi_lcd_msg("S1 UID:");
		} else {
		twi_lcd_msg("S2 UID:");
	}
	
	twi_lcd_cmd(0xC0);
	
	uidString[0] = '\0';
	
	for(uint8_t i = 0; i < currentUID->size && i < 5; i++) {
		byteToHex(currentUID->uidByte[i], hexByte);
		strcat(uidString, hexByte);
		if (i < currentUID->size - 1 && i < 4) {
			strcat(uidString, " ");
		}
	}
	
	twi_lcd_msg(uidString);
}

void byteToHex(uint8_t value, char* hexString) {
	const char hex[] = "0123456789ABCDEF";
	hexString[0] = hex[value >> 4];
	hexString[1] = hex[value & 0x0F];
	hexString[2] = '\0';
}

// Función para seleccionar el lector activo
void selectReader(uint8_t reader) {
	if (reader == 1) {
		PORTB &= ~(1<<SS1_PIN);  // SS1 low
		PORTB |= (1<<SS2_PIN);   // SS2 high
		} else if (reader == 2) {
		PORTB |= (1<<SS1_PIN);   // SS1 high
		PORTB &= ~(1<<SS2_PIN);  // SS2 low
	}
}

// Implementación de funciones SPI y MFRC522
void SPI_Init(void) {
	DDRB |= (1<<MOSI_PIN)|(1<<SCK_PIN)|(1<<SS1_PIN)|(1<<SS2_PIN);
	DDRB &= ~(1<<MISO_PIN);
	DDRD |= (1<<RST_PIN);
	
	PORTB |= (1<<SS1_PIN)|(1<<SS2_PIN);
	
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
}

uint8_t SPI_Transfer(uint8_t data) {
	SPDR = data;
	while(!(SPSR & (1<<SPIF)));
	return SPDR;
}

void MFRC522_Init(uint8_t reader) {
	MFRC522_Reset(reader);
	
	MFRC522_WriteRegister(TModeReg, 0x8D, reader);
	MFRC522_WriteRegister(TPrescalerReg, 0x3E, reader);
	MFRC522_WriteRegister(TReloadRegL, 30, reader);
	MFRC522_WriteRegister(TReloadRegH, 0, reader);
	
	MFRC522_WriteRegister(TxAutoReg, 0x40, reader);
	MFRC522_WriteRegister(ModeReg, 0x3D, reader);
	
	MFRC522_AntennaOn(reader);
}

void MFRC522_Reset(uint8_t reader) {
	MFRC522_WriteRegister(CommandReg, PCD_RESETPHASE, reader);
}

uint8_t MFRC522_ReadRegister(uint8_t reg, uint8_t reader) {
	uint8_t value;
	selectReader(reader);
	SPI_Transfer(((reg<<1)&0x7E)|0x80);
	value = SPI_Transfer(0x00);
	PORTB |= (1<<SS1_PIN)|(1<<SS2_PIN);
	return value;
}

void MFRC522_WriteRegister(uint8_t reg, uint8_t value, uint8_t reader) {
	selectReader(reader);
	SPI_Transfer((reg<<1)&0x7E);
	SPI_Transfer(value);
	PORTB |= (1<<SS1_PIN)|(1<<SS2_PIN);
}

void MFRC522_SetBitMask(uint8_t reg, uint8_t mask, uint8_t reader) {
	uint8_t tmp = MFRC522_ReadRegister(reg, reader);
	MFRC522_WriteRegister(reg, tmp | mask, reader);
}

void MFRC522_ClearBitMask(uint8_t reg, uint8_t mask, uint8_t reader) {
	uint8_t tmp = MFRC522_ReadRegister(reg, reader);
	MFRC522_WriteRegister(reg, tmp & (~mask), reader);
}

void MFRC522_AntennaOn(uint8_t reader) {
	uint8_t temp = MFRC522_ReadRegister(TxControlReg, reader);
	if (!(temp & 0x03)) {
		MFRC522_SetBitMask(TxControlReg, 0x03, reader);
	}
}

uint8_t MFRC522_ToCard(uint8_t command, uint8_t *sendData, uint8_t sendLen, uint8_t *backData, uint16_t *backLen, uint8_t reader) {
	uint8_t status = MI_ERR;
	uint8_t irqEn = 0x00;
	uint8_t waitIRq = 0x00;
	uint8_t lastBits;
	uint8_t n;
	uint16_t i;
	
	switch (command) {
		case PCD_AUTHENT:
		irqEn = 0x12;
		waitIRq = 0x10;
		break;
		case PCD_TRANSCEIVE:
		irqEn = 0x77;
		waitIRq = 0x30;
		break;
		default:
		break;
	}
	
	MFRC522_WriteRegister(ComIEnReg, irqEn|0x80, reader);
	MFRC522_ClearBitMask(ComIrqReg, 0x80, reader);
	MFRC522_SetBitMask(FIFOLevelReg, 0x80, reader);
	
	MFRC522_WriteRegister(CommandReg, PCD_IDLE, reader);
	
	for (i=0; i<sendLen; i++) {
		MFRC522_WriteRegister(FIFODataReg, sendData[i], reader);
	}
	
	MFRC522_WriteRegister(CommandReg, command, reader);
	if (command == PCD_TRANSCEIVE) {
		MFRC522_SetBitMask(BitFramingReg, 0x80, reader);
	}
	
	i = 2000;
	do {
		n = MFRC522_ReadRegister(ComIrqReg, reader);
		i--;
	} while ((i!=0) && !(n&0x01) && !(n&waitIRq));
	
	MFRC522_ClearBitMask(BitFramingReg, 0x80, reader);
	
	if (i != 0) {
		if(!(MFRC522_ReadRegister(ErrorReg, reader) & 0x1B)) {
			status = MI_OK;
			if (n & irqEn & 0x01) {
				status = MI_NOTAGERR;
			}
			
			if (command == PCD_TRANSCEIVE) {
				n = MFRC522_ReadRegister(FIFOLevelReg, reader);
				lastBits = MFRC522_ReadRegister(ControlReg, reader) & 0x07;
				if (lastBits) {
					*backLen = (n-1)*8 + lastBits;
					} else {
					*backLen = n*8;
				}
				
				if (n == 0) {
					n = 1;
				}
				if (n > 16) {
					n = 16;
				}
				
				for (i=0; i<n; i++) {
					backData[i] = MFRC522_ReadRegister(FIFODataReg, reader);
				}
			}
			} else {
			status = MI_ERR;
		}
	}
	
	return status;
}

uint8_t MFRC522_Request(uint8_t reqMode, uint8_t *TagType, uint8_t reader) {
	uint8_t status;
	uint16_t backBits;
	
	MFRC522_WriteRegister(BitFramingReg, 0x07, reader);
	
	TagType[0] = reqMode;
	status = MFRC522_ToCard(PCD_TRANSCEIVE, TagType, 1, TagType, &backBits, reader);
	
	if ((status != MI_OK) || (backBits != 0x10)) {
		status = MI_ERR;
	}
	
	return status;
}

uint8_t MFRC522_Anticoll(uint8_t *serNum, uint8_t reader) {
	uint8_t status;
	uint8_t i;
	uint8_t serNumCheck=0;
	uint16_t unLen;
	
	MFRC522_WriteRegister(BitFramingReg, 0x00, reader);
	
	serNum[0] = PICC_CMD_SEL_CL1;
	serNum[1] = 0x20;
	status = MFRC522_ToCard(PCD_TRANSCEIVE, serNum, 2, serNum, &unLen, reader);
	
	if (status == MI_OK) {
		for (i=0; i<4; i++) {
			serNumCheck ^= serNum[i];
		}
		if (serNumCheck != serNum[i]) {
			status = MI_ERR;
		}
	}
	
	return status;
}

uint8_t MFRC522_IsNewCardPresent(uint8_t reader) {
	uint8_t status;
	uint8_t TagType[2];
	
	status = MFRC522_Request(PICC_CMD_REQA, TagType, reader);
	if (status == MI_OK) {
		return 1;
		} else {
		return 0;
	}
}

uint8_t MFRC522_ReadCardSerial(uint8_t reader) {
	uint8_t status;
	uint8_t serNum[5];
	uint8_t i;
	
	status = MFRC522_Anticoll(serNum, reader);
	if (status == MI_OK) {
		// Guardar la UID en la variable correspondiente al lector
		if (reader == 1) {
			cardUID1.size = 4; // UID de 4 bytes para tarjetas MIFARE Classic
			for (i = 0; i < 4; i++) {
				cardUID1.uidByte[i] = serNum[i];
			}
			} else if (reader == 2) {
			cardUID2.size = 4; // UID de 4 bytes para tarjetas MIFARE Classic
			for (i = 0; i < 4; i++) {
				cardUID2.uidByte[i] = serNum[i];
			}
		}
		return 1;
		} else {
		return 0;
	}
}
